/**
 * generated by Xtext
 */
package org.muml.uppaal.scoping;

import java.util.Iterator;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.muml.uppaal.NTA;
import org.muml.uppaal.core.NamedElement;
import org.muml.uppaal.core.TypedElement;
import org.muml.uppaal.declarations.ParameterContainer;
import org.muml.uppaal.declarations.SystemDeclarations;
import org.muml.uppaal.declarations.TypeDeclaration;
import org.muml.uppaal.declarations.TypedDeclaration;
import org.muml.uppaal.declarations.TypedElementContainer;
import org.muml.uppaal.declarations.Variable;
import org.muml.uppaal.expressions.DataPrefixExpression;
import org.muml.uppaal.expressions.Expression;
import org.muml.uppaal.expressions.IdentifierExpression;
import org.muml.uppaal.expressions.QuantificationExpression;
import org.muml.uppaal.expressions.ScopedIdentifierExpression;
import org.muml.uppaal.parsable.IdentifiableLocation;
import org.muml.uppaal.statements.Block;
import org.muml.uppaal.statements.Iteration;
import org.muml.uppaal.templates.Edge;
import org.muml.uppaal.templates.Selection;
import org.muml.uppaal.templates.Template;
import org.muml.uppaal.types.DeclaredType;
import org.muml.uppaal.types.StdLib;
import org.muml.uppaal.types.StructTypeSpecification;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it
 * 
 * Custom scoping for UPPAALs XML format and programming language.
 */
@SuppressWarnings("all")
public class UppaalXMLScopeProvider extends AbstractDeclarativeScopeProvider {
  /**
   * Enumeration to distinguish between different aims for the scoping, i.e. whether we are
   * interested in TypedElements or Types. As this may change during scoping (e.g. when we
   * encounter an array structure) we need to be able to change it on-the-fly.
   */
  private enum ScopeMode {
    TYPES,
    
    TYPED_ELEMENTS,
    
    TYPES_AND_TYPED_ELEMENTS;
  }
  
  /**
   * Helper method that appends the TypedElements of a TypedElementContainer to a given
   * Iterable for NamedElements.
   */
  private Function2<Iterable<NamedElement>, TypedElementContainer, Iterable<NamedElement>> TypedElementContainerReduction = new Function2<Iterable<NamedElement>, TypedElementContainer, Iterable<NamedElement>>() {
    @Override
    public Iterable<NamedElement> apply(final Iterable<NamedElement> a, final TypedElementContainer b) {
      Iterable<NamedElement> _filter = Iterables.<NamedElement>filter(b.getElements(), NamedElement.class);
      return Iterables.<NamedElement>concat(a, _filter);
    }
  };
  
  /**
   * Helper method that appends the Types of a TypeDeclaration to a given
   * Iterable for NamedElements.
   */
  private Function2<Iterable<NamedElement>, TypeDeclaration, Iterable<NamedElement>> TypeDeclarationReduction = new Function2<Iterable<NamedElement>, TypeDeclaration, Iterable<NamedElement>>() {
    @Override
    public Iterable<NamedElement> apply(final Iterable<NamedElement> a, final TypeDeclaration b) {
      Iterable<NamedElement> _filter = Iterables.<NamedElement>filter(b.getType(), NamedElement.class);
      return Iterables.<NamedElement>concat(a, _filter);
    }
  };
  
  /**
   * Helper method that returns the QualifiedName of an IdentifiableLocation (= the id).
   */
  private Function<IdentifiableLocation, QualifiedName> getNameOfLocation = new Function<IdentifiableLocation, QualifiedName>() {
    @Override
    public QualifiedName apply(final IdentifiableLocation it) {
      return QualifiedName.create(it.getId());
    }
  };
  
  /**
   * Method that is called via reflection whenever the identifier attribute of an
   * IdentifierExpression needs to be resolved.
   * 
   * @param context Instance of IdentifierExpression.
   * @param ref Instance of the reference, i.e. the identifier attribute.
   * 
   * @return Hopefully a matching scope for the given identifier.
   */
  public IScope scope_IdentifierExpression_identifier(final EObject context, final EReference ref) {
    return this.getIdentifierScope(((IdentifierExpression) context));
  }
  
  /**
   * Method that is called when the source attribute of an edge needs to be resolved.
   * 
   * @param context Edge instance.
   * @param ref EReference instance of the source attribute.
   * 
   * @return Scope for the source attribute.
   */
  public IScope scope_Edge_source(final EObject context, final EReference ref) {
    IScope _xblockexpression = null;
    {
      EObject _eContainer = context.eContainer();
      final Template container = ((Template) _eContainer);
      _xblockexpression = Scopes.<IdentifiableLocation>scopeFor(
        Iterables.<IdentifiableLocation>filter(container.getLocation(), IdentifiableLocation.class), 
        this.getNameOfLocation, IScope.NULLSCOPE);
    }
    return _xblockexpression;
  }
  
  /**
   * Method that is called when the target attribute of an Edge needs to be resolved.
   * 
   * @param context Edge instance.
   * @param ref EReference instance of the target attribute.
   * 
   * @return Scope for the target attribute.
   */
  public IScope scope_Edge_target(final EObject context, final EReference ref) {
    IScope _xblockexpression = null;
    {
      EObject _eContainer = context.eContainer();
      final Template container = ((Template) _eContainer);
      _xblockexpression = Scopes.<IdentifiableLocation>scopeFor(
        Iterables.<IdentifiableLocation>filter(container.getLocation(), IdentifiableLocation.class), 
        this.getNameOfLocation, IScope.NULLSCOPE);
    }
    return _xblockexpression;
  }
  
  /**
   * Method that is called when the init attribute of a Template needs to be resolved.
   * 
   * @param context Template instance.
   * @param ref EReference instance for the init attribute.
   * 
   * @return Scope for the init attribute.
   */
  public IScope scope_Template_init(final EObject context, final EReference ref) {
    IScope _xblockexpression = null;
    {
      EObject _eContainer = context.eContainer();
      final Template template = ((Template) _eContainer);
      _xblockexpression = Scopes.scopeFor(template.getLocation());
    }
    return _xblockexpression;
  }
  
  /**
   * Main method to find the scope corresponding to a given IdentifierExpression.
   * It checks for certain special cases an then delegates to more specialized
   * methods.
   * 
   * @param identifier The IdentifierExpression that needs resolving.
   * 
   * @return Scope for the IdentifierExpression.
   */
  private IScope getIdentifierScope(final IdentifierExpression identifier) {
    IScope _xblockexpression = null;
    {
      EObject _eContainer = identifier.eContainer();
      boolean _matched = false;
      if (_eContainer instanceof TypedElementContainer) {
        _matched=true;
      }
      if (!_matched) {
        if (_eContainer instanceof TypeDeclaration) {
          _matched=true;
        }
      }
      if (_matched) {
        boolean _equals = "typeDefinition".equals(identifier.eContainmentFeature().getName());
        if (_equals) {
          return this.getRecursiveScope(identifier, UppaalXMLScopeProvider.ScopeMode.TYPES);
        }
      }
      if (!_matched) {
        if (_eContainer instanceof DataPrefixExpression) {
          _matched=true;
          return this.getRecursiveScope(identifier, UppaalXMLScopeProvider.ScopeMode.TYPES);
        }
      }
      _xblockexpression = this.getRecursiveScope(identifier, UppaalXMLScopeProvider.ScopeMode.TYPED_ELEMENTS);
    }
    return _xblockexpression;
  }
  
  /**
   * Checks whether the given ScopedIdentifierExpression follows the structure that
   * we can scope, i.e. if the "scope" is either an IdentifierExpression or a valid
   * ScopedIdentifierExpression and the identifier is an IdentifierExpression.
   * 
   * @param expr The ScopedIdentifierExpression to check.
   * 
   * @return A boolean indicating whether the structure is valid or not.
   */
  private boolean checkScopedIdentifierExpressionStructure(final ScopedIdentifierExpression expr) {
    Expression _scope = expr.getScope();
    boolean _matched = false;
    if (_scope instanceof IdentifierExpression) {
      _matched=true;
    }
    if (!_matched) {
      if (_scope instanceof ScopedIdentifierExpression) {
        _matched=true;
      }
    }
    if (_matched) {
      return true;
    }
    return false;
  }
  
  /**
   * Specifically scopes ScopedIdentifierExpressions. The method assumes that the
   * structure of the expression is valid, i.e. checkScopedIdentifierExpression
   * returned true.
   * 
   * @param expr The ScopedIdentifierExpression whose identifier attribute should
   * be resolved.
   * 
   * @return A scope that hopefully includes the referenced element.
   */
  private IScope getScopedIdentifierExpressionScope(final ScopedIdentifierExpression expr) {
    StructTypeSpecification struct = null;
    IScope scope = IScope.NULLSCOPE;
    IdentifierExpression identifier = null;
    Expression _scope = expr.getScope();
    boolean _matched = false;
    if (_scope instanceof IdentifierExpression) {
      _matched=true;
      Expression _scope_1 = expr.getScope();
      identifier = ((IdentifierExpression) _scope_1);
    }
    if (!_matched) {
      if (_scope instanceof ScopedIdentifierExpression) {
        _matched=true;
        Expression _scope_1 = expr.getScope();
        identifier = ((ScopedIdentifierExpression) _scope_1).getIdentifier();
      }
    }
    NamedElement _identifier = identifier.getIdentifier();
    if ((_identifier instanceof TypedElement)) {
      NamedElement _identifier_1 = identifier.getIdentifier();
      Expression typeDefinition = ((TypedElement) _identifier_1).getTypeDefinition();
      while (((typeDefinition instanceof IdentifierExpression) && 
        (((IdentifierExpression) typeDefinition).getIdentifier() instanceof DeclaredType))) {
        NamedElement _identifier_2 = ((IdentifierExpression) typeDefinition).getIdentifier();
        typeDefinition = ((DeclaredType) _identifier_2).getTypeDefinition();
      }
      if ((typeDefinition instanceof StructTypeSpecification)) {
        struct = ((StructTypeSpecification) typeDefinition);
      }
    }
    boolean _notEquals = (!Objects.equal(struct, null));
    if (_notEquals) {
      Iterable<NamedElement> elements = this.<Iterable<NamedElement>, TypedDeclaration>bReduce(struct.getDeclaration(), this.emptyList(), this.TypedElementContainerReduction);
      scope = Scopes.scopeFor(elements, IScope.NULLSCOPE);
    }
    return scope;
  }
  
  /**
   * Recursive strategy to find the scope of arbitrary EObjects. Essentially, the
   * containment tree is traversed and on relevant objects the scope is extended.
   * It is recursive as we go up in the containment tree, thus encountering inner
   * scopes first and outer scopes last. This is easier to do with recursion.
   * 
   * @param obj EObject for which to calculate the scope.
   * @param mode Mode telling us whether to scope for TypedElements or Types.
   * 
   * @return An appropiate scope representation for the EObject.
   */
  private IScope getRecursiveScope(final EObject obj, final UppaalXMLScopeProvider.ScopeMode mode) {
    IScope _xblockexpression = null;
    {
      Iterable<NamedElement> elements = this.emptyList();
      EObject curObj = obj.eContainer();
      EObject lastObj = obj;
      UppaalXMLScopeProvider.ScopeMode curMode = mode;
      while ((!Objects.equal(curObj, null))) {
        {
          boolean _matched = false;
          if (curObj instanceof Variable) {
            _matched=true;
            boolean _equals = "index".equals(lastObj.eContainmentFeature().getName());
            if (_equals) {
              curMode = UppaalXMLScopeProvider.ScopeMode.TYPES_AND_TYPED_ELEMENTS;
            }
          }
          if (!_matched) {
            if (curObj instanceof ScopedIdentifierExpression) {
              _matched=true;
              if (("identifier".equals(lastObj.eContainmentFeature().getName()) && 
                this.checkScopedIdentifierExpressionStructure(((ScopedIdentifierExpression)curObj)))) {
                return this.getScopedIdentifierExpressionScope(((ScopedIdentifierExpression)curObj));
              }
            }
          }
          if ((Objects.equal(curMode, UppaalXMLScopeProvider.ScopeMode.TYPED_ELEMENTS) || Objects.equal(curMode, UppaalXMLScopeProvider.ScopeMode.TYPES_AND_TYPED_ELEMENTS))) {
            boolean _matched_1 = false;
            if (curObj instanceof NTA) {
              _matched_1=true;
              Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, TypedDeclaration>bReduce(Iterables.<TypedDeclaration>filter(((NTA)curObj).getGlobalDeclarations().getDeclaration(), TypedDeclaration.class), this.emptyList(), this.TypedElementContainerReduction);
              Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
              elements = _plus;
            }
            if (!_matched_1) {
              if (curObj instanceof Template) {
                _matched_1=true;
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, ParameterContainer>bReduce(((Template)curObj).getParameter(), this.emptyList(), this.TypedElementContainerReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                Iterable<NamedElement> _bReduce_1 = this.<Iterable<NamedElement>, TypedDeclaration>bReduce(Iterables.<TypedDeclaration>filter(((Template)curObj).getDeclarations().getDeclaration(), TypedDeclaration.class), this.emptyList(), this.TypedElementContainerReduction);
                Iterable<NamedElement> _plus_1 = Iterables.<NamedElement>concat(_plus, _bReduce_1);
                elements = _plus_1;
              }
            }
            if (!_matched_1) {
              if (curObj instanceof org.muml.uppaal.declarations.Function) {
                _matched_1=true;
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, ParameterContainer>bReduce(((org.muml.uppaal.declarations.Function)curObj).getParameter(), this.emptyList(), this.TypedElementContainerReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                elements = _plus;
              }
            }
            if (!_matched_1) {
              if (curObj instanceof Block) {
                _matched_1=true;
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, TypedDeclaration>bReduce(Iterables.<TypedDeclaration>filter(((Block)curObj).getDeclarations().getDeclaration(), TypedDeclaration.class), this.emptyList(), this.TypedElementContainerReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                elements = _plus;
              }
            }
            if (!_matched_1) {
              if (curObj instanceof Iteration) {
                _matched_1=true;
                Iterable<NamedElement> _filter = Iterables.<NamedElement>filter(((Iteration)curObj).getElements(), NamedElement.class);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _filter);
                elements = _plus;
              }
            }
            if (!_matched_1) {
              if (curObj instanceof SystemDeclarations) {
                _matched_1=true;
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, TypedDeclaration>bReduce(Iterables.<TypedDeclaration>filter(((SystemDeclarations)curObj).getDeclaration(), TypedDeclaration.class), this.emptyList(), this.TypedElementContainerReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                elements = _plus;
              }
            }
            if (!_matched_1) {
              if (curObj instanceof Edge) {
                _matched_1=true;
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, Selection>bReduce(((Edge)curObj).getSelection(), this.emptyList(), this.TypedElementContainerReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                elements = _plus;
              }
            }
            if (!_matched_1) {
              if (curObj instanceof QuantificationExpression) {
                _matched_1=true;
                Iterable<NamedElement> _filter = Iterables.<NamedElement>filter(((QuantificationExpression)curObj).getElements(), NamedElement.class);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _filter);
                elements = _plus;
              }
            }
          }
          if ((Objects.equal(curMode, UppaalXMLScopeProvider.ScopeMode.TYPES_AND_TYPED_ELEMENTS) || Objects.equal(curMode, UppaalXMLScopeProvider.ScopeMode.TYPES))) {
            boolean _matched_2 = false;
            if (curObj instanceof NTA) {
              _matched_2=true;
              Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, TypeDeclaration>bReduce(Iterables.<TypeDeclaration>filter(((NTA)curObj).getGlobalDeclarations().getDeclaration(), TypeDeclaration.class), this.emptyList(), this.TypeDeclarationReduction);
              Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
              Iterable<NamedElement> _predefinedTypes = this.getPredefinedTypes(((NTA)curObj));
              Iterable<NamedElement> _plus_1 = Iterables.<NamedElement>concat(_plus, _predefinedTypes);
              elements = _plus_1;
            }
            if (!_matched_2) {
              if (curObj instanceof Template) {
                _matched_2=true;
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, TypeDeclaration>bReduce(Iterables.<TypeDeclaration>filter(((Template)curObj).getDeclarations().getDeclaration(), TypeDeclaration.class), this.emptyList(), this.TypeDeclarationReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                elements = _plus;
              }
            }
            if (!_matched_2) {
              if (curObj instanceof SystemDeclarations) {
                _matched_2=true;
                Iterable<NamedElement> _bReduce = this.<Iterable<NamedElement>, TypeDeclaration>bReduce(Iterables.<TypeDeclaration>filter(((SystemDeclarations)curObj).getDeclaration(), TypeDeclaration.class), this.emptyList(), this.TypeDeclarationReduction);
                Iterable<NamedElement> _plus = Iterables.<NamedElement>concat(elements, _bReduce);
                elements = _plus;
              }
            }
          }
          int _size = IterableExtensions.size(elements);
          boolean _greaterThan = (_size > 0);
          if (_greaterThan) {
            return Scopes.scopeFor(elements, this.getRecursiveScope(curObj, mode));
          }
          lastObj = curObj;
          curObj = curObj.eContainer();
        }
      }
      _xblockexpression = IScope.NULLSCOPE;
    }
    return _xblockexpression;
  }
  
  /**
   * Creates an empty Iterable for NamedElements.
   * 
   * @return Empty Iterable for NamedElements.
   */
  private Iterable<NamedElement> emptyList() {
    Iterable<NamedElement> _xblockexpression = null;
    {
      final Iterable<NamedElement> emptyList = CollectionLiterals.<NamedElement>newArrayList();
      _xblockexpression = emptyList;
    }
    return _xblockexpression;
  }
  
  /**
   * Returns all the PredefinedTypes of the given NTA instance.
   * 
   * @param nta Instance of NTA.
   * 
   * @return Iterable of all the PredefinedTypes as NamedElements.
   */
  private Iterable<NamedElement> getPredefinedTypes(final NTA nta) {
    return CollectionLiterals.<NamedElement>newArrayList(
      StdLib.BOOL, 
      StdLib.CHAN, 
      StdLib.CLOCK, 
      StdLib.INT, 
      StdLib.VOID);
  }
  
  /**
   * Better reduction function that allows start values etc.
   * Thanks: http://shiggyenterprises.wordpress.com/2012/11/27/better-reduce-for-xtend/
   * 
   * @param iterable Iterable to reduce.
   * @param initial Initial value of the combined value.
   * @param fu Reduction function.
   * 
   * @return Reduced version of iterable.
   */
  private <T extends Object, V extends Object> T bReduce(final Iterable<V> iterable, final T initial, final Function2<? super T, ? super V, ? extends T> fu) {
    final Iterator<V> i = iterable.iterator();
    T out = initial;
    while (i.hasNext()) {
      out = fu.apply(out, i.next());
    }
    return out;
  }
}

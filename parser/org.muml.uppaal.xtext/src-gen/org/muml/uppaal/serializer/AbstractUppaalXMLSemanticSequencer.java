/*
 * generated by Xtext
 */
package org.muml.uppaal.serializer;

import java.util.Set;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.muml.uppaal.NTA;
import org.muml.uppaal.UppaalPackage;
import org.muml.uppaal.core.CorePackage;
import org.muml.uppaal.declarations.ArrayInitializer;
import org.muml.uppaal.declarations.DeclarationsPackage;
import org.muml.uppaal.declarations.ExpressionInitializer;
import org.muml.uppaal.declarations.Function;
import org.muml.uppaal.declarations.GlobalDeclarations;
import org.muml.uppaal.declarations.LocalDeclarations;
import org.muml.uppaal.declarations.ParameterContainer;
import org.muml.uppaal.declarations.SystemDeclarations;
import org.muml.uppaal.declarations.TypeDeclaration;
import org.muml.uppaal.declarations.TypedDeclaration;
import org.muml.uppaal.declarations.Variable;
import org.muml.uppaal.declarations.global.ChannelItem;
import org.muml.uppaal.declarations.global.ChannelPriorityDeclaration;
import org.muml.uppaal.declarations.global.ChannelPriorityGroup;
import org.muml.uppaal.declarations.global.DefaultItem;
import org.muml.uppaal.declarations.global.GlobalPackage;
import org.muml.uppaal.declarations.system.InstantiationList;
import org.muml.uppaal.declarations.system.ProgressMeasure;
import org.muml.uppaal.declarations.system.SystemPackage;
import org.muml.uppaal.declarations.system.TemplateDeclaration;
import org.muml.uppaal.expressions.ArithmeticExpression;
import org.muml.uppaal.expressions.AssignmentExpression;
import org.muml.uppaal.expressions.BitShiftExpression;
import org.muml.uppaal.expressions.BitwiseExpression;
import org.muml.uppaal.expressions.ChannelPrefixExpression;
import org.muml.uppaal.expressions.CompareExpression;
import org.muml.uppaal.expressions.ConditionExpression;
import org.muml.uppaal.expressions.DataPrefixExpression;
import org.muml.uppaal.expressions.ExpressionsPackage;
import org.muml.uppaal.expressions.FunctionCallExpression;
import org.muml.uppaal.expressions.IdentifierExpression;
import org.muml.uppaal.expressions.IncrementDecrementExpression;
import org.muml.uppaal.expressions.LiteralExpression;
import org.muml.uppaal.expressions.LogicalExpression;
import org.muml.uppaal.expressions.MinMaxExpression;
import org.muml.uppaal.expressions.NegationExpression;
import org.muml.uppaal.expressions.QuantificationExpression;
import org.muml.uppaal.expressions.ScopedIdentifierExpression;
import org.muml.uppaal.parsable.IdentifiableLocation;
import org.muml.uppaal.parsable.ParsablePackage;
import org.muml.uppaal.services.UppaalXMLGrammarAccess;
import org.muml.uppaal.statements.Block;
import org.muml.uppaal.statements.DoWhileLoop;
import org.muml.uppaal.statements.EmptyStatement;
import org.muml.uppaal.statements.ExpressionStatement;
import org.muml.uppaal.statements.ForLoop;
import org.muml.uppaal.statements.IfStatement;
import org.muml.uppaal.statements.Iteration;
import org.muml.uppaal.statements.ReturnStatement;
import org.muml.uppaal.statements.StatementsPackage;
import org.muml.uppaal.statements.WhileLoop;
import org.muml.uppaal.templates.Edge;
import org.muml.uppaal.templates.RedefinedTemplate;
import org.muml.uppaal.templates.Selection;
import org.muml.uppaal.templates.Synchronization;
import org.muml.uppaal.templates.Template;
import org.muml.uppaal.templates.TemplatesPackage;
import org.muml.uppaal.types.DeclaredType;
import org.muml.uppaal.types.IntegerBounds;
import org.muml.uppaal.types.RangeTypeSpecification;
import org.muml.uppaal.types.ScalarTypeSpecification;
import org.muml.uppaal.types.StructTypeSpecification;
import org.muml.uppaal.types.TypesPackage;
import org.muml.uppaal.visuals.Point;
import org.muml.uppaal.visuals.VisualsPackage;

import com.google.inject.Inject;

@SuppressWarnings("all")
public abstract class AbstractUppaalXMLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UppaalXMLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DeclarationsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DeclarationsPackage.ARRAY_INITIALIZER:
				sequence_ArrayInitializer(context, (ArrayInitializer) semanticObject); 
				return; 
			case DeclarationsPackage.EXPRESSION_INITIALIZER:
				sequence_ExpressionInitializer(context, (ExpressionInitializer) semanticObject); 
				return; 
			case DeclarationsPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case DeclarationsPackage.GLOBAL_DECLARATIONS:
				sequence_GlobalDeclarations(context, (GlobalDeclarations) semanticObject); 
				return; 
			case DeclarationsPackage.LOCAL_DECLARATIONS:
				if (rule == grammarAccess.getBlockDeclarationsRule()) {
					sequence_BlockDeclarations(context, (LocalDeclarations) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLocalDeclarationsRule()) {
					sequence_LocalDeclarations(context, (LocalDeclarations) semanticObject); 
					return; 
				}
				else break;
			case DeclarationsPackage.PARAMETER:
				sequence_Parameter(context, (org.muml.uppaal.declarations.Parameter) semanticObject); 
				return; 
			case DeclarationsPackage.PARAMETER_CONTAINER:
				sequence_ParameterContainer(context, (ParameterContainer) semanticObject); 
				return; 
			case DeclarationsPackage.SYSTEM_DECLARATIONS:
				sequence_SystemDeclarations(context, (SystemDeclarations) semanticObject); 
				return; 
			case DeclarationsPackage.TYPE_DECLARATION:
				sequence_TypeDeclaration(context, (TypeDeclaration) semanticObject); 
				return; 
			case DeclarationsPackage.TYPED_DECLARATION:
				if (rule == grammarAccess.getBlockTypedDeclarationRule()) {
					sequence_BlockTypedDeclaration(context, (TypedDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypedDeclarationRule()) {
					sequence_TypedDeclaration(context, (TypedDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypedElementRule()) {
					sequence_TypedElement(context, (TypedDeclaration) semanticObject); 
					return; 
				}
				else break;
			case DeclarationsPackage.VARIABLE:
				if (rule == grammarAccess.getVariableNameOnlyRule()) {
					sequence_VariableNameOnly(context, (Variable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableRule()) {
					sequence_Variable(context, (Variable) semanticObject); 
					return; 
				}
				else break;
			}
		else if (epackage == ExpressionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionsPackage.ARITHMETIC_EXPRESSION:
				sequence_ArithmeticExpression_Other_ArithmeticExpression_PlusMinus(context, (ArithmeticExpression) semanticObject); 
				return; 
			case ExpressionsPackage.ASSIGNMENT_EXPRESSION:
				sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
				return; 
			case ExpressionsPackage.BIT_SHIFT_EXPRESSION:
				sequence_BitShiftExpression(context, (BitShiftExpression) semanticObject); 
				return; 
			case ExpressionsPackage.BITWISE_EXPRESSION:
				sequence_BitwiseExpression_And_BitwiseExpression_Or_BitwiseExpression_Xor(context, (BitwiseExpression) semanticObject); 
				return; 
			case ExpressionsPackage.CHANNEL_PREFIX_EXPRESSION:
				sequence_ChannelPrefixExpression(context, (ChannelPrefixExpression) semanticObject); 
				return; 
			case ExpressionsPackage.COMPARE_EXPRESSION:
				sequence_CompareExpression_EqualUnequal_CompareExpression_Other(context, (CompareExpression) semanticObject); 
				return; 
			case ExpressionsPackage.CONDITION_EXPRESSION:
				sequence_ConditionExpression(context, (ConditionExpression) semanticObject); 
				return; 
			case ExpressionsPackage.DATA_PREFIX_EXPRESSION:
				sequence_DataPrefixExpression(context, (DataPrefixExpression) semanticObject); 
				return; 
			case ExpressionsPackage.FUNCTION_CALL_EXPRESSION:
				sequence_FunctionCallExpression(context, (FunctionCallExpression) semanticObject); 
				return; 
			case ExpressionsPackage.IDENTIFIER_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getQuantificationExpressionRule()
						|| rule == grammarAccess.getLogicalExpression_OrImplyRule()
						|| action == grammarAccess.getLogicalExpression_OrImplyAccess().getLogicalExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getLogicalExpression_AndRule()
						|| action == grammarAccess.getLogicalExpression_AndAccess().getLogicalExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getNegationExpressionRule()
						|| rule == grammarAccess.getAssignmentExpressionRule()
						|| action == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getConditionExpressionRule()
						|| action == grammarAccess.getConditionExpressionAccess().getConditionExpressionIfExpressionAction_1_0()
						|| rule == grammarAccess.getLogicalExpression_OrAlternativeRule()
						|| action == grammarAccess.getLogicalExpression_OrAlternativeAccess().getLogicalExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getLogicalExpression_AndAlternativeRule()
						|| action == grammarAccess.getLogicalExpression_AndAlternativeAccess().getLogicalExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getBitwiseExpression_OrRule()
						|| action == grammarAccess.getBitwiseExpression_OrAccess().getBitwiseExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getBitwiseExpression_XorRule()
						|| action == grammarAccess.getBitwiseExpression_XorAccess().getBitwiseExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getBitwiseExpression_AndRule()
						|| action == grammarAccess.getBitwiseExpression_AndAccess().getBitwiseExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getCompareExpression_EqualUnequalRule()
						|| action == grammarAccess.getCompareExpression_EqualUnequalAccess().getCompareExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getCompareExpression_OtherRule()
						|| action == grammarAccess.getCompareExpression_OtherAccess().getCompareExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getMinMaxExpressionRule()
						|| action == grammarAccess.getMinMaxExpressionAccess().getMinMaxExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getBitShiftExpressionRule()
						|| action == grammarAccess.getBitShiftExpressionAccess().getBitShiftExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getArithmeticExpression_PlusMinusRule()
						|| action == grammarAccess.getArithmeticExpression_PlusMinusAccess().getArithmeticExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getArithmeticExpression_OtherRule()
						|| action == grammarAccess.getArithmeticExpression_OtherAccess().getArithmeticExpressionFirstExprAction_1_0()
						|| rule == grammarAccess.getNegationExpression_AlternativeRule()
						|| rule == grammarAccess.getIncrementDecrementExpressionRule()
						|| rule == grammarAccess.getPreIncrementDecrementExpressionRule()
						|| rule == grammarAccess.getPostIncrementDecrementExpressionRule()
						|| action == grammarAccess.getPostIncrementDecrementExpressionAccess().getIncrementDecrementExpressionExpressionAction_1_0_0()
						|| rule == grammarAccess.getScopedIdentifierExpressionRule()
						|| action == grammarAccess.getScopedIdentifierExpressionAccess().getScopedIdentifierExpressionScopeAction_1_0()
						|| rule == grammarAccess.getTerminatingExpressionsRule()
						|| rule == grammarAccess.getIdentifierExpressionRule()) {
					sequence_IdentifierExpression(context, (IdentifierExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeExpressionRule()
						|| rule == grammarAccess.getSimpleIdentifierExpressionRule()) {
					sequence_SimpleIdentifierExpression(context, (IdentifierExpression) semanticObject); 
					return; 
				}
				else break;
			case ExpressionsPackage.INCREMENT_DECREMENT_EXPRESSION:
				sequence_PostIncrementDecrementExpression_PreIncrementDecrementExpression(context, (IncrementDecrementExpression) semanticObject); 
				return; 
			case ExpressionsPackage.LITERAL_EXPRESSION:
				sequence_LiteralExpression(context, (LiteralExpression) semanticObject); 
				return; 
			case ExpressionsPackage.LOGICAL_EXPRESSION:
				sequence_LogicalExpression_And_LogicalExpression_AndAlternative_LogicalExpression_OrAlternative_LogicalExpression_OrImply(context, (LogicalExpression) semanticObject); 
				return; 
			case ExpressionsPackage.MIN_MAX_EXPRESSION:
				sequence_MinMaxExpression(context, (MinMaxExpression) semanticObject); 
				return; 
			case ExpressionsPackage.NEGATION_EXPRESSION:
				sequence_NegationExpression_NegationExpression_Alternative(context, (NegationExpression) semanticObject); 
				return; 
			case ExpressionsPackage.QUANTIFICATION_EXPRESSION:
				sequence_QuantificationExpression(context, (QuantificationExpression) semanticObject); 
				return; 
			case ExpressionsPackage.SCOPED_IDENTIFIER_EXPRESSION:
				sequence_ScopedIdentifierExpression(context, (ScopedIdentifierExpression) semanticObject); 
				return; 
			}
		else if (epackage == GlobalPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GlobalPackage.CHANNEL_ITEM:
				sequence_ChannelItem(context, (ChannelItem) semanticObject); 
				return; 
			case GlobalPackage.CHANNEL_PRIORITY_DECLARATION:
				sequence_ChannelPriorityDeclaration(context, (ChannelPriorityDeclaration) semanticObject); 
				return; 
			case GlobalPackage.CHANNEL_PRIORITY_GROUP:
				sequence_ChannelPriorityGroup(context, (ChannelPriorityGroup) semanticObject); 
				return; 
			case GlobalPackage.DEFAULT_ITEM:
				sequence_DefaultItem(context, (DefaultItem) semanticObject); 
				return; 
			}
		else if (epackage == ParsablePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ParsablePackage.IDENTIFIABLE_LOCATION:
				sequence_Location(context, (IdentifiableLocation) semanticObject); 
				return; 
			}
		else if (epackage == StatementsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StatementsPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case StatementsPackage.DO_WHILE_LOOP:
				sequence_DoWhileLoop(context, (DoWhileLoop) semanticObject); 
				return; 
			case StatementsPackage.EMPTY_STATEMENT:
				sequence_EmptyStatement(context, (EmptyStatement) semanticObject); 
				return; 
			case StatementsPackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case StatementsPackage.FOR_LOOP:
				sequence_ForLoop(context, (ForLoop) semanticObject); 
				return; 
			case StatementsPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case StatementsPackage.ITERATION:
				sequence_Iteration(context, (Iteration) semanticObject); 
				return; 
			case StatementsPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case StatementsPackage.WHILE_LOOP:
				sequence_WhileLoop(context, (WhileLoop) semanticObject); 
				return; 
			}
		else if (epackage == SystemPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SystemPackage.INSTANTIATION_LIST:
				sequence_InstantiationList(context, (InstantiationList) semanticObject); 
				return; 
			case SystemPackage.PROGRESS_MEASURE:
				sequence_ProgressMeasure(context, (ProgressMeasure) semanticObject); 
				return; 
			case SystemPackage.SYSTEM:
				sequence_System(context, (org.muml.uppaal.declarations.system.System) semanticObject); 
				return; 
			case SystemPackage.TEMPLATE_DECLARATION:
				sequence_TemplateDeclaration(context, (TemplateDeclaration) semanticObject); 
				return; 
			}
		else if (epackage == TemplatesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TemplatesPackage.EDGE:
				sequence_Edge(context, (Edge) semanticObject); 
				return; 
			case TemplatesPackage.REDEFINED_TEMPLATE:
				sequence_RedefinedTemplate(context, (RedefinedTemplate) semanticObject); 
				return; 
			case TemplatesPackage.SELECTION:
				sequence_Selection(context, (Selection) semanticObject); 
				return; 
			case TemplatesPackage.SYNCHRONIZATION:
				sequence_SynchronizationLabel(context, (Synchronization) semanticObject); 
				return; 
			case TemplatesPackage.TEMPLATE:
				sequence_Template(context, (Template) semanticObject); 
				return; 
			}
		else if (epackage == TypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypesPackage.DECLARED_TYPE:
				sequence_DeclaredType(context, (DeclaredType) semanticObject); 
				return; 
			case TypesPackage.INTEGER_BOUNDS:
				sequence_IntegerBounds(context, (IntegerBounds) semanticObject); 
				return; 
			case TypesPackage.RANGE_TYPE_SPECIFICATION:
				sequence_RangeTypeSpecification(context, (RangeTypeSpecification) semanticObject); 
				return; 
			case TypesPackage.SCALAR_TYPE_SPECIFICATION:
				sequence_ScalarTypeSpecification(context, (ScalarTypeSpecification) semanticObject); 
				return; 
			case TypesPackage.STRUCT_TYPE_SPECIFICATION:
				sequence_StructTypeSpecification(context, (StructTypeSpecification) semanticObject); 
				return; 
			}
		else if (epackage == UppaalPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UppaalPackage.NTA:
				sequence_NTA(context, (NTA) semanticObject); 
				return; 
			}
		else if (epackage == VisualsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case VisualsPackage.POINT:
				sequence_Point(context, (Point) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns ArithmeticExpression
	 *     QuantificationExpression returns ArithmeticExpression
	 *     LogicalExpression_OrImply returns ArithmeticExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns ArithmeticExpression
	 *     LogicalExpression_And returns ArithmeticExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns ArithmeticExpression
	 *     NegationExpression returns ArithmeticExpression
	 *     AssignmentExpression returns ArithmeticExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns ArithmeticExpression
	 *     ConditionExpression returns ArithmeticExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns ArithmeticExpression
	 *     LogicalExpression_OrAlternative returns ArithmeticExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns ArithmeticExpression
	 *     LogicalExpression_AndAlternative returns ArithmeticExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns ArithmeticExpression
	 *     BitwiseExpression_Or returns ArithmeticExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns ArithmeticExpression
	 *     BitwiseExpression_Xor returns ArithmeticExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns ArithmeticExpression
	 *     BitwiseExpression_And returns ArithmeticExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns ArithmeticExpression
	 *     CompareExpression_EqualUnequal returns ArithmeticExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns ArithmeticExpression
	 *     CompareExpression_Other returns ArithmeticExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns ArithmeticExpression
	 *     MinMaxExpression returns ArithmeticExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns ArithmeticExpression
	 *     BitShiftExpression returns ArithmeticExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns ArithmeticExpression
	 *     ArithmeticExpression_PlusMinus returns ArithmeticExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns ArithmeticExpression
	 *     ArithmeticExpression_Other returns ArithmeticExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns ArithmeticExpression
	 *     NegationExpression_Alternative returns ArithmeticExpression
	 *     IncrementDecrementExpression returns ArithmeticExpression
	 *     PreIncrementDecrementExpression returns ArithmeticExpression
	 *     PostIncrementDecrementExpression returns ArithmeticExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns ArithmeticExpression
	 *     ScopedIdentifierExpression returns ArithmeticExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns ArithmeticExpression
	 *     TerminatingExpressions returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (
	 *         (firstExpr=ArithmeticExpression_PlusMinus_ArithmeticExpression_1_0 operator=ArithmeticOperator_PlusMinus secondExpr=ArithmeticExpression_Other) | 
	 *         (firstExpr=ArithmeticExpression_Other_ArithmeticExpression_1_0 operator=ArithmeticOperator_Other secondExpr=NegationExpression_Alternative)
	 *     )
	 */
	protected void sequence_ArithmeticExpression_Other_ArithmeticExpression_PlusMinus(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Initializer returns ArrayInitializer
	 *     ArrayInitializer returns ArrayInitializer
	 *
	 * Constraint:
	 *     (initializer+=Initializer initializer+=Initializer*)
	 */
	protected void sequence_ArrayInitializer(ISerializationContext context, ArrayInitializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AssignmentExpression
	 *     QuantificationExpression returns AssignmentExpression
	 *     LogicalExpression_OrImply returns AssignmentExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns AssignmentExpression
	 *     LogicalExpression_And returns AssignmentExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns AssignmentExpression
	 *     NegationExpression returns AssignmentExpression
	 *     AssignmentExpression returns AssignmentExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns AssignmentExpression
	 *     ConditionExpression returns AssignmentExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns AssignmentExpression
	 *     LogicalExpression_OrAlternative returns AssignmentExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns AssignmentExpression
	 *     LogicalExpression_AndAlternative returns AssignmentExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns AssignmentExpression
	 *     BitwiseExpression_Or returns AssignmentExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns AssignmentExpression
	 *     BitwiseExpression_Xor returns AssignmentExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns AssignmentExpression
	 *     BitwiseExpression_And returns AssignmentExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns AssignmentExpression
	 *     CompareExpression_EqualUnequal returns AssignmentExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns AssignmentExpression
	 *     CompareExpression_Other returns AssignmentExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns AssignmentExpression
	 *     MinMaxExpression returns AssignmentExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns AssignmentExpression
	 *     BitShiftExpression returns AssignmentExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns AssignmentExpression
	 *     ArithmeticExpression_PlusMinus returns AssignmentExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns AssignmentExpression
	 *     ArithmeticExpression_Other returns AssignmentExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns AssignmentExpression
	 *     NegationExpression_Alternative returns AssignmentExpression
	 *     IncrementDecrementExpression returns AssignmentExpression
	 *     PreIncrementDecrementExpression returns AssignmentExpression
	 *     PostIncrementDecrementExpression returns AssignmentExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns AssignmentExpression
	 *     ScopedIdentifierExpression returns AssignmentExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns AssignmentExpression
	 *     TerminatingExpressions returns AssignmentExpression
	 *
	 * Constraint:
	 *     (firstExpr=AssignmentExpression_AssignmentExpression_1_0 operator=AssignmentOperator secondExpr=ConditionExpression)
	 */
	protected void sequence_AssignmentExpression(ISerializationContext context, AssignmentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__FIRST_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__FIRST_EXPR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.ASSIGNMENT_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.ASSIGNMENT_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__SECOND_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__SECOND_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionFirstExprAction_1_0(), semanticObject.getFirstExpr());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getOperatorAssignmentOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getSecondExprConditionExpressionParserRuleCall_1_2_0(), semanticObject.getSecondExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BitShiftExpression
	 *     QuantificationExpression returns BitShiftExpression
	 *     LogicalExpression_OrImply returns BitShiftExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns BitShiftExpression
	 *     LogicalExpression_And returns BitShiftExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns BitShiftExpression
	 *     NegationExpression returns BitShiftExpression
	 *     AssignmentExpression returns BitShiftExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns BitShiftExpression
	 *     ConditionExpression returns BitShiftExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns BitShiftExpression
	 *     LogicalExpression_OrAlternative returns BitShiftExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns BitShiftExpression
	 *     LogicalExpression_AndAlternative returns BitShiftExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns BitShiftExpression
	 *     BitwiseExpression_Or returns BitShiftExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns BitShiftExpression
	 *     BitwiseExpression_Xor returns BitShiftExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns BitShiftExpression
	 *     BitwiseExpression_And returns BitShiftExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns BitShiftExpression
	 *     CompareExpression_EqualUnequal returns BitShiftExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns BitShiftExpression
	 *     CompareExpression_Other returns BitShiftExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns BitShiftExpression
	 *     MinMaxExpression returns BitShiftExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns BitShiftExpression
	 *     BitShiftExpression returns BitShiftExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns BitShiftExpression
	 *     ArithmeticExpression_PlusMinus returns BitShiftExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns BitShiftExpression
	 *     ArithmeticExpression_Other returns BitShiftExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns BitShiftExpression
	 *     NegationExpression_Alternative returns BitShiftExpression
	 *     IncrementDecrementExpression returns BitShiftExpression
	 *     PreIncrementDecrementExpression returns BitShiftExpression
	 *     PostIncrementDecrementExpression returns BitShiftExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns BitShiftExpression
	 *     ScopedIdentifierExpression returns BitShiftExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns BitShiftExpression
	 *     TerminatingExpressions returns BitShiftExpression
	 *
	 * Constraint:
	 *     (firstExpr=BitShiftExpression_BitShiftExpression_1_0 operator=BitShiftOperator secondExpr=ArithmeticExpression_PlusMinus)
	 */
	protected void sequence_BitShiftExpression(ISerializationContext context, BitShiftExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__FIRST_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__FIRST_EXPR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BIT_SHIFT_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BIT_SHIFT_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__SECOND_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__SECOND_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitShiftExpressionAccess().getBitShiftExpressionFirstExprAction_1_0(), semanticObject.getFirstExpr());
		feeder.accept(grammarAccess.getBitShiftExpressionAccess().getOperatorBitShiftOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getBitShiftExpressionAccess().getSecondExprArithmeticExpression_PlusMinusParserRuleCall_1_2_0(), semanticObject.getSecondExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BitwiseExpression
	 *     QuantificationExpression returns BitwiseExpression
	 *     LogicalExpression_OrImply returns BitwiseExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns BitwiseExpression
	 *     LogicalExpression_And returns BitwiseExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns BitwiseExpression
	 *     NegationExpression returns BitwiseExpression
	 *     AssignmentExpression returns BitwiseExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns BitwiseExpression
	 *     ConditionExpression returns BitwiseExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns BitwiseExpression
	 *     LogicalExpression_OrAlternative returns BitwiseExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns BitwiseExpression
	 *     LogicalExpression_AndAlternative returns BitwiseExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns BitwiseExpression
	 *     BitwiseExpression_Or returns BitwiseExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns BitwiseExpression
	 *     BitwiseExpression_Xor returns BitwiseExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns BitwiseExpression
	 *     BitwiseExpression_And returns BitwiseExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns BitwiseExpression
	 *     CompareExpression_EqualUnequal returns BitwiseExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns BitwiseExpression
	 *     CompareExpression_Other returns BitwiseExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns BitwiseExpression
	 *     MinMaxExpression returns BitwiseExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns BitwiseExpression
	 *     BitShiftExpression returns BitwiseExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns BitwiseExpression
	 *     ArithmeticExpression_PlusMinus returns BitwiseExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns BitwiseExpression
	 *     ArithmeticExpression_Other returns BitwiseExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns BitwiseExpression
	 *     NegationExpression_Alternative returns BitwiseExpression
	 *     IncrementDecrementExpression returns BitwiseExpression
	 *     PreIncrementDecrementExpression returns BitwiseExpression
	 *     PostIncrementDecrementExpression returns BitwiseExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns BitwiseExpression
	 *     ScopedIdentifierExpression returns BitwiseExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns BitwiseExpression
	 *     TerminatingExpressions returns BitwiseExpression
	 *
	 * Constraint:
	 *     (
	 *         (firstExpr=BitwiseExpression_Or_BitwiseExpression_1_0 operator=BitwiseOperator_Or secondExpr=BitwiseExpression_Xor) | 
	 *         (firstExpr=BitwiseExpression_Xor_BitwiseExpression_1_0 operator=BitwiseOperator_Xor secondExpr=BitwiseExpression_And) | 
	 *         (firstExpr=BitwiseExpression_And_BitwiseExpression_1_0 operator=BitwiseOperator_And secondExpr=CompareExpression_EqualUnequal)
	 *     )
	 */
	protected void sequence_BitwiseExpression_And_BitwiseExpression_Or_BitwiseExpression_Xor(ISerializationContext context, BitwiseExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockDeclarations returns LocalDeclarations
	 *
	 * Constraint:
	 *     (declaration+=BlockTypedDeclaration | declaration+=TypeDeclaration)*
	 */
	protected void sequence_BlockDeclarations(ISerializationContext context, LocalDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockTypedDeclaration returns TypedDeclaration
	 *
	 * Constraint:
	 *     (typeDefinition=TypeExpression elements+=Variable elements+=Variable*)
	 */
	protected void sequence_BlockTypedDeclaration(ISerializationContext context, TypedDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Block
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (declarations=BlockDeclarations statement+=Statement*)
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PriorityItem returns ChannelItem
	 *     ChannelItem returns ChannelItem
	 *
	 * Constraint:
	 *     channelExpression=IdentifierExpression
	 */
	protected void sequence_ChannelItem(ISerializationContext context, ChannelItem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GlobalPackage.Literals.CHANNEL_ITEM__CHANNEL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GlobalPackage.Literals.CHANNEL_ITEM__CHANNEL_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChannelItemAccess().getChannelExpressionIdentifierExpressionParserRuleCall_0(), semanticObject.getChannelExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeExpression returns ChannelPrefixExpression
	 *     ChannelPrefixExpression returns ChannelPrefixExpression
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (urgent=ChannelPrefixExpression_Urgent broadcast=ChannelPrefixExpression_Broadcast?) | 
	 *             (broadcast=ChannelPrefixExpression_Broadcast urgent=ChannelPrefixExpression_Urgent?)
	 *         ) 
	 *         channelType=[Type|CHAN_KEYWORD]
	 *     )
	 */
	protected void sequence_ChannelPrefixExpression(ISerializationContext context, ChannelPrefixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChannelPriorityDeclaration returns ChannelPriorityDeclaration
	 *
	 * Constraint:
	 *     (groups+=ChannelPriorityGroup groups+=ChannelPriorityGroup*)
	 */
	protected void sequence_ChannelPriorityDeclaration(ISerializationContext context, ChannelPriorityDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ChannelPriorityGroup returns ChannelPriorityGroup
	 *
	 * Constraint:
	 *     (items+=PriorityItem items+=PriorityItem*)
	 */
	protected void sequence_ChannelPriorityGroup(ISerializationContext context, ChannelPriorityGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CompareExpression
	 *     QuantificationExpression returns CompareExpression
	 *     LogicalExpression_OrImply returns CompareExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns CompareExpression
	 *     LogicalExpression_And returns CompareExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns CompareExpression
	 *     NegationExpression returns CompareExpression
	 *     AssignmentExpression returns CompareExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns CompareExpression
	 *     ConditionExpression returns CompareExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns CompareExpression
	 *     LogicalExpression_OrAlternative returns CompareExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns CompareExpression
	 *     LogicalExpression_AndAlternative returns CompareExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns CompareExpression
	 *     BitwiseExpression_Or returns CompareExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns CompareExpression
	 *     BitwiseExpression_Xor returns CompareExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns CompareExpression
	 *     BitwiseExpression_And returns CompareExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns CompareExpression
	 *     CompareExpression_EqualUnequal returns CompareExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns CompareExpression
	 *     CompareExpression_Other returns CompareExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns CompareExpression
	 *     MinMaxExpression returns CompareExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns CompareExpression
	 *     BitShiftExpression returns CompareExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns CompareExpression
	 *     ArithmeticExpression_PlusMinus returns CompareExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns CompareExpression
	 *     ArithmeticExpression_Other returns CompareExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns CompareExpression
	 *     NegationExpression_Alternative returns CompareExpression
	 *     IncrementDecrementExpression returns CompareExpression
	 *     PreIncrementDecrementExpression returns CompareExpression
	 *     PostIncrementDecrementExpression returns CompareExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns CompareExpression
	 *     ScopedIdentifierExpression returns CompareExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns CompareExpression
	 *     TerminatingExpressions returns CompareExpression
	 *
	 * Constraint:
	 *     (
	 *         (firstExpr=CompareExpression_EqualUnequal_CompareExpression_1_0 operator=CompareOperator_EqualUnequal secondExpr=CompareExpression_Other) | 
	 *         (firstExpr=CompareExpression_Other_CompareExpression_1_0 operator=CompareOperator_Other secondExpr=MinMaxExpression)
	 *     )
	 */
	protected void sequence_CompareExpression_EqualUnequal_CompareExpression_Other(ISerializationContext context, CompareExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ConditionExpression
	 *     QuantificationExpression returns ConditionExpression
	 *     LogicalExpression_OrImply returns ConditionExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns ConditionExpression
	 *     LogicalExpression_And returns ConditionExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns ConditionExpression
	 *     NegationExpression returns ConditionExpression
	 *     AssignmentExpression returns ConditionExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns ConditionExpression
	 *     ConditionExpression returns ConditionExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns ConditionExpression
	 *     LogicalExpression_OrAlternative returns ConditionExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns ConditionExpression
	 *     LogicalExpression_AndAlternative returns ConditionExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns ConditionExpression
	 *     BitwiseExpression_Or returns ConditionExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns ConditionExpression
	 *     BitwiseExpression_Xor returns ConditionExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns ConditionExpression
	 *     BitwiseExpression_And returns ConditionExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns ConditionExpression
	 *     CompareExpression_EqualUnequal returns ConditionExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns ConditionExpression
	 *     CompareExpression_Other returns ConditionExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns ConditionExpression
	 *     MinMaxExpression returns ConditionExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns ConditionExpression
	 *     BitShiftExpression returns ConditionExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns ConditionExpression
	 *     ArithmeticExpression_PlusMinus returns ConditionExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns ConditionExpression
	 *     ArithmeticExpression_Other returns ConditionExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns ConditionExpression
	 *     NegationExpression_Alternative returns ConditionExpression
	 *     IncrementDecrementExpression returns ConditionExpression
	 *     PreIncrementDecrementExpression returns ConditionExpression
	 *     PostIncrementDecrementExpression returns ConditionExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns ConditionExpression
	 *     ScopedIdentifierExpression returns ConditionExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns ConditionExpression
	 *     TerminatingExpressions returns ConditionExpression
	 *
	 * Constraint:
	 *     (ifExpression=ConditionExpression_ConditionExpression_1_0 thenExpression=Expression elseExpression=LogicalExpression_OrAlternative)
	 */
	protected void sequence_ConditionExpression(ISerializationContext context, ConditionExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.CONDITION_EXPRESSION__IF_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.CONDITION_EXPRESSION__IF_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.CONDITION_EXPRESSION__THEN_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.CONDITION_EXPRESSION__THEN_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.CONDITION_EXPRESSION__ELSE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.CONDITION_EXPRESSION__ELSE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionExpressionAccess().getConditionExpressionIfExpressionAction_1_0(), semanticObject.getIfExpression());
		feeder.accept(grammarAccess.getConditionExpressionAccess().getThenExpressionExpressionParserRuleCall_1_2_0(), semanticObject.getThenExpression());
		feeder.accept(grammarAccess.getConditionExpressionAccess().getElseExpressionLogicalExpression_OrAlternativeParserRuleCall_1_4_0(), semanticObject.getElseExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeExpression returns DataPrefixExpression
	 *     DataPrefixExpression returns DataPrefixExpression
	 *
	 * Constraint:
	 *     (
	 *         prefix=DataVariablePrefix 
	 *         (
	 *             dataTypeExpression=RangeTypeSpecification | 
	 *             dataTypeExpression=ScalarTypeSpecification | 
	 *             dataTypeExpression=StructTypeSpecification | 
	 *             dataTypeExpression=SimpleIdentifierExpression
	 *         )
	 *     )
	 */
	protected void sequence_DataPrefixExpression(ISerializationContext context, DataPrefixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclaredType returns DeclaredType
	 *
	 * Constraint:
	 *     name=UPPAAL_IDENTIFIER
	 */
	protected void sequence_DeclaredType(ISerializationContext context, DeclaredType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CorePackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CorePackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclaredTypeAccess().getNameUPPAAL_IDENTIFIERParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PriorityItem returns DefaultItem
	 *     DefaultItem returns DefaultItem
	 *
	 * Constraint:
	 *     {DefaultItem}
	 */
	protected void sequence_DefaultItem(ISerializationContext context, DefaultItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DoWhileLoop
	 *     DoWhileLoop returns DoWhileLoop
	 *
	 * Constraint:
	 *     (statement=Statement expression=Expression)
	 */
	protected void sequence_DoWhileLoop(ISerializationContext context, DoWhileLoop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.DO_WHILE_LOOP__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.DO_WHILE_LOOP__STATEMENT));
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.DO_WHILE_LOOP__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.DO_WHILE_LOOP__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoWhileLoopAccess().getStatementStatementParserRuleCall_1_0(), semanticObject.getStatement());
		feeder.accept(grammarAccess.getDoWhileLoopAccess().getExpressionExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Edge returns Edge
	 *
	 * Constraint:
	 *     (
	 *         colorCode=STRING* 
	 *         source=[Location|STRING] 
	 *         target=[Location|STRING] 
	 *         (
	 *             (comment=CommentLabel | synchronization=SynchronizationLabel | guard=Expression)? 
	 *             (update+=Expression update+=Expression*)? 
	 *             (selection+=Selection selection+=Selection*)?
	 *         )+ 
	 *         bendPoint+=Point*
	 *     )
	 */
	protected void sequence_Edge(ISerializationContext context, Edge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns EmptyStatement
	 *     EmptyStatement returns EmptyStatement
	 *
	 * Constraint:
	 *     {EmptyStatement}
	 */
	protected void sequence_EmptyStatement(ISerializationContext context, EmptyStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Initializer returns ExpressionInitializer
	 *     ExpressionInitializer returns ExpressionInitializer
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ExpressionInitializer(ISerializationContext context, ExpressionInitializer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DeclarationsPackage.Literals.EXPRESSION_INITIALIZER__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DeclarationsPackage.Literals.EXPRESSION_INITIALIZER__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionInitializerAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExpressionStatement
	 *     ExpressionStatement returns ExpressionStatement
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ExpressionStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStatementAccess().getExpressionExpressionParserRuleCall_0_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForLoop
	 *     ForLoop returns ForLoop
	 *
	 * Constraint:
	 *     (initialization=Expression condition=Expression iteration=Expression statement=Statement)
	 */
	protected void sequence_ForLoop(ISerializationContext context, ForLoop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.FOR_LOOP__INITIALIZATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.FOR_LOOP__INITIALIZATION));
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.FOR_LOOP__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.FOR_LOOP__CONDITION));
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.FOR_LOOP__ITERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.FOR_LOOP__ITERATION));
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.FOR_LOOP__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.FOR_LOOP__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForLoopAccess().getInitializationExpressionParserRuleCall_2_0(), semanticObject.getInitialization());
		feeder.accept(grammarAccess.getForLoopAccess().getConditionExpressionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getForLoopAccess().getIterationExpressionParserRuleCall_6_0(), semanticObject.getIteration());
		feeder.accept(grammarAccess.getForLoopAccess().getStatementStatementParserRuleCall_8_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FunctionCallExpression
	 *     QuantificationExpression returns FunctionCallExpression
	 *     LogicalExpression_OrImply returns FunctionCallExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns FunctionCallExpression
	 *     LogicalExpression_And returns FunctionCallExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns FunctionCallExpression
	 *     NegationExpression returns FunctionCallExpression
	 *     AssignmentExpression returns FunctionCallExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns FunctionCallExpression
	 *     ConditionExpression returns FunctionCallExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns FunctionCallExpression
	 *     LogicalExpression_OrAlternative returns FunctionCallExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns FunctionCallExpression
	 *     LogicalExpression_AndAlternative returns FunctionCallExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns FunctionCallExpression
	 *     BitwiseExpression_Or returns FunctionCallExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns FunctionCallExpression
	 *     BitwiseExpression_Xor returns FunctionCallExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns FunctionCallExpression
	 *     BitwiseExpression_And returns FunctionCallExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns FunctionCallExpression
	 *     CompareExpression_EqualUnequal returns FunctionCallExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns FunctionCallExpression
	 *     CompareExpression_Other returns FunctionCallExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns FunctionCallExpression
	 *     MinMaxExpression returns FunctionCallExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns FunctionCallExpression
	 *     BitShiftExpression returns FunctionCallExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns FunctionCallExpression
	 *     ArithmeticExpression_PlusMinus returns FunctionCallExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns FunctionCallExpression
	 *     ArithmeticExpression_Other returns FunctionCallExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns FunctionCallExpression
	 *     NegationExpression_Alternative returns FunctionCallExpression
	 *     IncrementDecrementExpression returns FunctionCallExpression
	 *     PreIncrementDecrementExpression returns FunctionCallExpression
	 *     PostIncrementDecrementExpression returns FunctionCallExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns FunctionCallExpression
	 *     ScopedIdentifierExpression returns FunctionCallExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns FunctionCallExpression
	 *     TerminatingExpressions returns FunctionCallExpression
	 *     FunctionCallExpression returns FunctionCallExpression
	 *
	 * Constraint:
	 *     (function=[Function|UPPAAL_IDENTIFIER] (argument+=Expression argument+=Expression*)?)
	 */
	protected void sequence_FunctionCallExpression(ISerializationContext context, FunctionCallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=UPPAAL_IDENTIFIER (parameter+=ParameterContainer parameter+=ParameterContainer*)? block=Block)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GlobalDeclarations returns GlobalDeclarations
	 *
	 * Constraint:
	 *     (declaration+=TypedDeclaration | declaration+=TypeDeclaration | channelPriority=ChannelPriorityDeclaration)*
	 */
	protected void sequence_GlobalDeclarations(ISerializationContext context, GlobalDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IdentifierExpression
	 *     QuantificationExpression returns IdentifierExpression
	 *     LogicalExpression_OrImply returns IdentifierExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns IdentifierExpression
	 *     LogicalExpression_And returns IdentifierExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns IdentifierExpression
	 *     NegationExpression returns IdentifierExpression
	 *     AssignmentExpression returns IdentifierExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns IdentifierExpression
	 *     ConditionExpression returns IdentifierExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns IdentifierExpression
	 *     LogicalExpression_OrAlternative returns IdentifierExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns IdentifierExpression
	 *     LogicalExpression_AndAlternative returns IdentifierExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns IdentifierExpression
	 *     BitwiseExpression_Or returns IdentifierExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns IdentifierExpression
	 *     BitwiseExpression_Xor returns IdentifierExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns IdentifierExpression
	 *     BitwiseExpression_And returns IdentifierExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns IdentifierExpression
	 *     CompareExpression_EqualUnequal returns IdentifierExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns IdentifierExpression
	 *     CompareExpression_Other returns IdentifierExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns IdentifierExpression
	 *     MinMaxExpression returns IdentifierExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns IdentifierExpression
	 *     BitShiftExpression returns IdentifierExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns IdentifierExpression
	 *     ArithmeticExpression_PlusMinus returns IdentifierExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns IdentifierExpression
	 *     ArithmeticExpression_Other returns IdentifierExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns IdentifierExpression
	 *     NegationExpression_Alternative returns IdentifierExpression
	 *     IncrementDecrementExpression returns IdentifierExpression
	 *     PreIncrementDecrementExpression returns IdentifierExpression
	 *     PostIncrementDecrementExpression returns IdentifierExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns IdentifierExpression
	 *     ScopedIdentifierExpression returns IdentifierExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns IdentifierExpression
	 *     TerminatingExpressions returns IdentifierExpression
	 *     IdentifierExpression returns IdentifierExpression
	 *
	 * Constraint:
	 *     (identifier=[NamedElement|UPPAAL_TYPE_OR_IDENTIFIER] index+=Expression*)
	 */
	protected void sequence_IdentifierExpression(ISerializationContext context, IdentifierExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (ifExpression=Expression thenStatement=Statement elseStatement=Statement?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InstantiationList returns InstantiationList
	 *
	 * Constraint:
	 *     (template+=[AbstractTemplate|UPPAAL_IDENTIFIER] template+=[AbstractTemplate|UPPAAL_IDENTIFIER]*)
	 */
	protected void sequence_InstantiationList(ISerializationContext context, InstantiationList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IntegerBounds returns IntegerBounds
	 *
	 * Constraint:
	 *     (lowerBound=Expression upperBound=Expression)
	 */
	protected void sequence_IntegerBounds(ISerializationContext context, IntegerBounds semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.INTEGER_BOUNDS__LOWER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.INTEGER_BOUNDS__LOWER_BOUND));
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.INTEGER_BOUNDS__UPPER_BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.INTEGER_BOUNDS__UPPER_BOUND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerBoundsAccess().getLowerBoundExpressionParserRuleCall_1_0(), semanticObject.getLowerBound());
		feeder.accept(grammarAccess.getIntegerBoundsAccess().getUpperBoundExpressionParserRuleCall_3_0(), semanticObject.getUpperBound());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Iteration
	 *     Iteration returns Iteration
	 *
	 * Constraint:
	 *     (elements+=VariableNameOnly typeDefinition=TypeExpression statement=Statement)
	 */
	protected void sequence_Iteration(ISerializationContext context, Iteration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralExpression
	 *     QuantificationExpression returns LiteralExpression
	 *     LogicalExpression_OrImply returns LiteralExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns LiteralExpression
	 *     LogicalExpression_And returns LiteralExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns LiteralExpression
	 *     NegationExpression returns LiteralExpression
	 *     AssignmentExpression returns LiteralExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns LiteralExpression
	 *     ConditionExpression returns LiteralExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns LiteralExpression
	 *     LogicalExpression_OrAlternative returns LiteralExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns LiteralExpression
	 *     LogicalExpression_AndAlternative returns LiteralExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns LiteralExpression
	 *     BitwiseExpression_Or returns LiteralExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns LiteralExpression
	 *     BitwiseExpression_Xor returns LiteralExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns LiteralExpression
	 *     BitwiseExpression_And returns LiteralExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns LiteralExpression
	 *     CompareExpression_EqualUnequal returns LiteralExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns LiteralExpression
	 *     CompareExpression_Other returns LiteralExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns LiteralExpression
	 *     MinMaxExpression returns LiteralExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns LiteralExpression
	 *     BitShiftExpression returns LiteralExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns LiteralExpression
	 *     ArithmeticExpression_PlusMinus returns LiteralExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns LiteralExpression
	 *     ArithmeticExpression_Other returns LiteralExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns LiteralExpression
	 *     NegationExpression_Alternative returns LiteralExpression
	 *     IncrementDecrementExpression returns LiteralExpression
	 *     PreIncrementDecrementExpression returns LiteralExpression
	 *     PostIncrementDecrementExpression returns LiteralExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns LiteralExpression
	 *     ScopedIdentifierExpression returns LiteralExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns LiteralExpression
	 *     TerminatingExpressions returns LiteralExpression
	 *     LiteralExpression returns LiteralExpression
	 *
	 * Constraint:
	 *     text=LiteralExpressionText
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, LiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.LITERAL_EXPRESSION__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.LITERAL_EXPRESSION__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralExpressionAccess().getTextLiteralExpressionTextParserRuleCall_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LocalDeclarations returns LocalDeclarations
	 *
	 * Constraint:
	 *     (declaration+=TypedDeclaration | declaration+=TypeDeclaration)*
	 */
	protected void sequence_LocalDeclarations(ISerializationContext context, LocalDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Location returns IdentifiableLocation
	 *
	 * Constraint:
	 *     (
	 *         (id=STRING | position=Point | colorCode=STRING)* 
	 *         name=ID? 
	 *         comment=CommentLabel? 
	 *         (invariant=Expression? comment=CommentLabel?)* 
	 *         locationTimeKind=LocationKind?
	 *     )
	 */
	protected void sequence_Location(ISerializationContext context, IdentifiableLocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LogicalExpression
	 *     QuantificationExpression returns LogicalExpression
	 *     LogicalExpression_OrImply returns LogicalExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns LogicalExpression
	 *     LogicalExpression_And returns LogicalExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns LogicalExpression
	 *     NegationExpression returns LogicalExpression
	 *     AssignmentExpression returns LogicalExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns LogicalExpression
	 *     ConditionExpression returns LogicalExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns LogicalExpression
	 *     LogicalExpression_OrAlternative returns LogicalExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns LogicalExpression
	 *     LogicalExpression_AndAlternative returns LogicalExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns LogicalExpression
	 *     BitwiseExpression_Or returns LogicalExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns LogicalExpression
	 *     BitwiseExpression_Xor returns LogicalExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns LogicalExpression
	 *     BitwiseExpression_And returns LogicalExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns LogicalExpression
	 *     CompareExpression_EqualUnequal returns LogicalExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns LogicalExpression
	 *     CompareExpression_Other returns LogicalExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns LogicalExpression
	 *     MinMaxExpression returns LogicalExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns LogicalExpression
	 *     BitShiftExpression returns LogicalExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns LogicalExpression
	 *     ArithmeticExpression_PlusMinus returns LogicalExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns LogicalExpression
	 *     ArithmeticExpression_Other returns LogicalExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns LogicalExpression
	 *     NegationExpression_Alternative returns LogicalExpression
	 *     IncrementDecrementExpression returns LogicalExpression
	 *     PreIncrementDecrementExpression returns LogicalExpression
	 *     PostIncrementDecrementExpression returns LogicalExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns LogicalExpression
	 *     ScopedIdentifierExpression returns LogicalExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns LogicalExpression
	 *     TerminatingExpressions returns LogicalExpression
	 *
	 * Constraint:
	 *     (
	 *         (firstExpr=LogicalExpression_OrImply_LogicalExpression_1_0 operator=LogicalOperator_OrImply secondExpr=LogicalExpression_And) | 
	 *         (firstExpr=LogicalExpression_And_LogicalExpression_1_0 operator=LogicalOperator_And secondExpr=NegationExpression) | 
	 *         (
	 *             firstExpr=LogicalExpression_OrAlternative_LogicalExpression_1_0 
	 *             operator=LogicalOperator_OrAlternative 
	 *             secondExpr=LogicalExpression_AndAlternative
	 *         ) | 
	 *         (firstExpr=LogicalExpression_AndAlternative_LogicalExpression_1_0 operator=LogicalOperator_AndAlternative secondExpr=BitwiseExpression_Or)
	 *     )
	 */
	protected void sequence_LogicalExpression_And_LogicalExpression_AndAlternative_LogicalExpression_OrAlternative_LogicalExpression_OrImply(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MinMaxExpression
	 *     QuantificationExpression returns MinMaxExpression
	 *     LogicalExpression_OrImply returns MinMaxExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns MinMaxExpression
	 *     LogicalExpression_And returns MinMaxExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns MinMaxExpression
	 *     NegationExpression returns MinMaxExpression
	 *     AssignmentExpression returns MinMaxExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns MinMaxExpression
	 *     ConditionExpression returns MinMaxExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns MinMaxExpression
	 *     LogicalExpression_OrAlternative returns MinMaxExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns MinMaxExpression
	 *     LogicalExpression_AndAlternative returns MinMaxExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns MinMaxExpression
	 *     BitwiseExpression_Or returns MinMaxExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns MinMaxExpression
	 *     BitwiseExpression_Xor returns MinMaxExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns MinMaxExpression
	 *     BitwiseExpression_And returns MinMaxExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns MinMaxExpression
	 *     CompareExpression_EqualUnequal returns MinMaxExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns MinMaxExpression
	 *     CompareExpression_Other returns MinMaxExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns MinMaxExpression
	 *     MinMaxExpression returns MinMaxExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns MinMaxExpression
	 *     BitShiftExpression returns MinMaxExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns MinMaxExpression
	 *     ArithmeticExpression_PlusMinus returns MinMaxExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns MinMaxExpression
	 *     ArithmeticExpression_Other returns MinMaxExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns MinMaxExpression
	 *     NegationExpression_Alternative returns MinMaxExpression
	 *     IncrementDecrementExpression returns MinMaxExpression
	 *     PreIncrementDecrementExpression returns MinMaxExpression
	 *     PostIncrementDecrementExpression returns MinMaxExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns MinMaxExpression
	 *     ScopedIdentifierExpression returns MinMaxExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns MinMaxExpression
	 *     TerminatingExpressions returns MinMaxExpression
	 *
	 * Constraint:
	 *     (firstExpr=MinMaxExpression_MinMaxExpression_1_0 operator=MinMaxOperator secondExpr=BitShiftExpression)
	 */
	protected void sequence_MinMaxExpression(ISerializationContext context, MinMaxExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__FIRST_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__FIRST_EXPR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.MIN_MAX_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.MIN_MAX_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__SECOND_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.BINARY_EXPRESSION__SECOND_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinMaxExpressionAccess().getMinMaxExpressionFirstExprAction_1_0(), semanticObject.getFirstExpr());
		feeder.accept(grammarAccess.getMinMaxExpressionAccess().getOperatorMinMaxOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getMinMaxExpressionAccess().getSecondExprBitShiftExpressionParserRuleCall_1_2_0(), semanticObject.getSecondExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NTA returns NTA
	 *
	 * Constraint:
	 *     (globalDeclarations=GlobalDeclarations? template+=Template+ systemDeclarations=SystemDeclarations)
	 */
	protected void sequence_NTA(ISerializationContext context, NTA semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NegationExpression
	 *     QuantificationExpression returns NegationExpression
	 *     LogicalExpression_OrImply returns NegationExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns NegationExpression
	 *     LogicalExpression_And returns NegationExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns NegationExpression
	 *     NegationExpression returns NegationExpression
	 *     AssignmentExpression returns NegationExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns NegationExpression
	 *     ConditionExpression returns NegationExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns NegationExpression
	 *     LogicalExpression_OrAlternative returns NegationExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns NegationExpression
	 *     LogicalExpression_AndAlternative returns NegationExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns NegationExpression
	 *     BitwiseExpression_Or returns NegationExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns NegationExpression
	 *     BitwiseExpression_Xor returns NegationExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns NegationExpression
	 *     BitwiseExpression_And returns NegationExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns NegationExpression
	 *     CompareExpression_EqualUnequal returns NegationExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns NegationExpression
	 *     CompareExpression_Other returns NegationExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns NegationExpression
	 *     MinMaxExpression returns NegationExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns NegationExpression
	 *     BitShiftExpression returns NegationExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns NegationExpression
	 *     ArithmeticExpression_PlusMinus returns NegationExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns NegationExpression
	 *     ArithmeticExpression_Other returns NegationExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns NegationExpression
	 *     NegationExpression_Alternative returns NegationExpression
	 *     IncrementDecrementExpression returns NegationExpression
	 *     PreIncrementDecrementExpression returns NegationExpression
	 *     PostIncrementDecrementExpression returns NegationExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns NegationExpression
	 *     ScopedIdentifierExpression returns NegationExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns NegationExpression
	 *     TerminatingExpressions returns NegationExpression
	 *
	 * Constraint:
	 *     (negatedExpression=AssignmentExpression | negatedExpression=IncrementDecrementExpression)
	 */
	protected void sequence_NegationExpression_NegationExpression_Alternative(ISerializationContext context, NegationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterContainer returns ParameterContainer
	 *
	 * Constraint:
	 *     (typeDefinition=TypeExpression elements+=Parameter)
	 */
	protected void sequence_ParameterContainer(ISerializationContext context, ParameterContainer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (callType=CallType? name=UPPAAL_IDENTIFIER)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.muml.uppaal.declarations.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Point returns Point
	 *
	 * Constraint:
	 *     (x=QUOTED_INT | y=QUOTED_INT)*
	 */
	protected void sequence_Point(ISerializationContext context, Point semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IncrementDecrementExpression
	 *     QuantificationExpression returns IncrementDecrementExpression
	 *     LogicalExpression_OrImply returns IncrementDecrementExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns IncrementDecrementExpression
	 *     LogicalExpression_And returns IncrementDecrementExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns IncrementDecrementExpression
	 *     NegationExpression returns IncrementDecrementExpression
	 *     AssignmentExpression returns IncrementDecrementExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns IncrementDecrementExpression
	 *     ConditionExpression returns IncrementDecrementExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns IncrementDecrementExpression
	 *     LogicalExpression_OrAlternative returns IncrementDecrementExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns IncrementDecrementExpression
	 *     LogicalExpression_AndAlternative returns IncrementDecrementExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns IncrementDecrementExpression
	 *     BitwiseExpression_Or returns IncrementDecrementExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns IncrementDecrementExpression
	 *     BitwiseExpression_Xor returns IncrementDecrementExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns IncrementDecrementExpression
	 *     BitwiseExpression_And returns IncrementDecrementExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns IncrementDecrementExpression
	 *     CompareExpression_EqualUnequal returns IncrementDecrementExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns IncrementDecrementExpression
	 *     CompareExpression_Other returns IncrementDecrementExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns IncrementDecrementExpression
	 *     MinMaxExpression returns IncrementDecrementExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns IncrementDecrementExpression
	 *     BitShiftExpression returns IncrementDecrementExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns IncrementDecrementExpression
	 *     ArithmeticExpression_PlusMinus returns IncrementDecrementExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns IncrementDecrementExpression
	 *     ArithmeticExpression_Other returns IncrementDecrementExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns IncrementDecrementExpression
	 *     NegationExpression_Alternative returns IncrementDecrementExpression
	 *     IncrementDecrementExpression returns IncrementDecrementExpression
	 *     PreIncrementDecrementExpression returns IncrementDecrementExpression
	 *     PostIncrementDecrementExpression returns IncrementDecrementExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns IncrementDecrementExpression
	 *     ScopedIdentifierExpression returns IncrementDecrementExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns IncrementDecrementExpression
	 *     TerminatingExpressions returns IncrementDecrementExpression
	 *
	 * Constraint:
	 *     (
	 *         ((operator=IncrementOperator | operator=DecrementOperator) expression=PreIncrementDecrementExpression) | 
	 *         (expression=PostIncrementDecrementExpression_IncrementDecrementExpression_1_0_0 (operator=IncrementOperator | operator=DecrementOperator))
	 *     )
	 */
	protected void sequence_PostIncrementDecrementExpression_PreIncrementDecrementExpression(ISerializationContext context, IncrementDecrementExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProgressMeasure returns ProgressMeasure
	 *
	 * Constraint:
	 *     expression+=Expression+
	 */
	protected void sequence_ProgressMeasure(ISerializationContext context, ProgressMeasure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns QuantificationExpression
	 *     QuantificationExpression returns QuantificationExpression
	 *     LogicalExpression_OrImply returns QuantificationExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns QuantificationExpression
	 *     LogicalExpression_And returns QuantificationExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns QuantificationExpression
	 *     NegationExpression returns QuantificationExpression
	 *     AssignmentExpression returns QuantificationExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns QuantificationExpression
	 *     ConditionExpression returns QuantificationExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns QuantificationExpression
	 *     LogicalExpression_OrAlternative returns QuantificationExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns QuantificationExpression
	 *     LogicalExpression_AndAlternative returns QuantificationExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns QuantificationExpression
	 *     BitwiseExpression_Or returns QuantificationExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns QuantificationExpression
	 *     BitwiseExpression_Xor returns QuantificationExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns QuantificationExpression
	 *     BitwiseExpression_And returns QuantificationExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns QuantificationExpression
	 *     CompareExpression_EqualUnequal returns QuantificationExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns QuantificationExpression
	 *     CompareExpression_Other returns QuantificationExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns QuantificationExpression
	 *     MinMaxExpression returns QuantificationExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns QuantificationExpression
	 *     BitShiftExpression returns QuantificationExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns QuantificationExpression
	 *     ArithmeticExpression_PlusMinus returns QuantificationExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns QuantificationExpression
	 *     ArithmeticExpression_Other returns QuantificationExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns QuantificationExpression
	 *     NegationExpression_Alternative returns QuantificationExpression
	 *     IncrementDecrementExpression returns QuantificationExpression
	 *     PreIncrementDecrementExpression returns QuantificationExpression
	 *     PostIncrementDecrementExpression returns QuantificationExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns QuantificationExpression
	 *     ScopedIdentifierExpression returns QuantificationExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns QuantificationExpression
	 *     TerminatingExpressions returns QuantificationExpression
	 *
	 * Constraint:
	 *     (quantifier=Quantifier elements+=VariableNameOnly typeDefinition=TypeExpression expression=LogicalExpression_OrImply)
	 */
	protected void sequence_QuantificationExpression(ISerializationContext context, QuantificationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeExpression returns RangeTypeSpecification
	 *     RangeTypeSpecification returns RangeTypeSpecification
	 *
	 * Constraint:
	 *     bounds=IntegerBounds
	 */
	protected void sequence_RangeTypeSpecification(ISerializationContext context, RangeTypeSpecification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.RANGE_TYPE_SPECIFICATION__BOUNDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.RANGE_TYPE_SPECIFICATION__BOUNDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeTypeSpecificationAccess().getBoundsIntegerBoundsParserRuleCall_1_0(), semanticObject.getBounds());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RedefinedTemplate returns RedefinedTemplate
	 *
	 * Constraint:
	 *     (name=UPPAAL_IDENTIFIER referredTemplate=[Template|ID])
	 */
	protected void sequence_RedefinedTemplate(ISerializationContext context, RedefinedTemplate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CorePackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CorePackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, TemplatesPackage.Literals.REDEFINED_TEMPLATE__REFERRED_TEMPLATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplatesPackage.Literals.REDEFINED_TEMPLATE__REFERRED_TEMPLATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRedefinedTemplateAccess().getNameUPPAAL_IDENTIFIERParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRedefinedTemplateAccess().getReferredTemplateTemplateIDTerminalRuleCall_2_0_1(), semanticObject.eGet(TemplatesPackage.Literals.REDEFINED_TEMPLATE__REFERRED_TEMPLATE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     returnExpression=Expression?
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeExpression returns ScalarTypeSpecification
	 *     ScalarTypeSpecification returns ScalarTypeSpecification
	 *
	 * Constraint:
	 *     sizeExpression=Expression
	 */
	protected void sequence_ScalarTypeSpecification(ISerializationContext context, ScalarTypeSpecification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.SCALAR_TYPE_SPECIFICATION__SIZE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.SCALAR_TYPE_SPECIFICATION__SIZE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScalarTypeSpecificationAccess().getSizeExpressionExpressionParserRuleCall_2_0(), semanticObject.getSizeExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ScopedIdentifierExpression
	 *     QuantificationExpression returns ScopedIdentifierExpression
	 *     LogicalExpression_OrImply returns ScopedIdentifierExpression
	 *     LogicalExpression_OrImply.LogicalExpression_1_0 returns ScopedIdentifierExpression
	 *     LogicalExpression_And returns ScopedIdentifierExpression
	 *     LogicalExpression_And.LogicalExpression_1_0 returns ScopedIdentifierExpression
	 *     NegationExpression returns ScopedIdentifierExpression
	 *     AssignmentExpression returns ScopedIdentifierExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns ScopedIdentifierExpression
	 *     ConditionExpression returns ScopedIdentifierExpression
	 *     ConditionExpression.ConditionExpression_1_0 returns ScopedIdentifierExpression
	 *     LogicalExpression_OrAlternative returns ScopedIdentifierExpression
	 *     LogicalExpression_OrAlternative.LogicalExpression_1_0 returns ScopedIdentifierExpression
	 *     LogicalExpression_AndAlternative returns ScopedIdentifierExpression
	 *     LogicalExpression_AndAlternative.LogicalExpression_1_0 returns ScopedIdentifierExpression
	 *     BitwiseExpression_Or returns ScopedIdentifierExpression
	 *     BitwiseExpression_Or.BitwiseExpression_1_0 returns ScopedIdentifierExpression
	 *     BitwiseExpression_Xor returns ScopedIdentifierExpression
	 *     BitwiseExpression_Xor.BitwiseExpression_1_0 returns ScopedIdentifierExpression
	 *     BitwiseExpression_And returns ScopedIdentifierExpression
	 *     BitwiseExpression_And.BitwiseExpression_1_0 returns ScopedIdentifierExpression
	 *     CompareExpression_EqualUnequal returns ScopedIdentifierExpression
	 *     CompareExpression_EqualUnequal.CompareExpression_1_0 returns ScopedIdentifierExpression
	 *     CompareExpression_Other returns ScopedIdentifierExpression
	 *     CompareExpression_Other.CompareExpression_1_0 returns ScopedIdentifierExpression
	 *     MinMaxExpression returns ScopedIdentifierExpression
	 *     MinMaxExpression.MinMaxExpression_1_0 returns ScopedIdentifierExpression
	 *     BitShiftExpression returns ScopedIdentifierExpression
	 *     BitShiftExpression.BitShiftExpression_1_0 returns ScopedIdentifierExpression
	 *     ArithmeticExpression_PlusMinus returns ScopedIdentifierExpression
	 *     ArithmeticExpression_PlusMinus.ArithmeticExpression_1_0 returns ScopedIdentifierExpression
	 *     ArithmeticExpression_Other returns ScopedIdentifierExpression
	 *     ArithmeticExpression_Other.ArithmeticExpression_1_0 returns ScopedIdentifierExpression
	 *     NegationExpression_Alternative returns ScopedIdentifierExpression
	 *     IncrementDecrementExpression returns ScopedIdentifierExpression
	 *     PreIncrementDecrementExpression returns ScopedIdentifierExpression
	 *     PostIncrementDecrementExpression returns ScopedIdentifierExpression
	 *     PostIncrementDecrementExpression.IncrementDecrementExpression_1_0_0 returns ScopedIdentifierExpression
	 *     ScopedIdentifierExpression returns ScopedIdentifierExpression
	 *     ScopedIdentifierExpression.ScopedIdentifierExpression_1_0 returns ScopedIdentifierExpression
	 *     TerminatingExpressions returns ScopedIdentifierExpression
	 *
	 * Constraint:
	 *     (scope=ScopedIdentifierExpression_ScopedIdentifierExpression_1_0 identifier=IdentifierExpression)
	 */
	protected void sequence_ScopedIdentifierExpression(ISerializationContext context, ScopedIdentifierExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.SCOPED_IDENTIFIER_EXPRESSION__SCOPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.SCOPED_IDENTIFIER_EXPRESSION__SCOPE));
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.SCOPED_IDENTIFIER_EXPRESSION__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.SCOPED_IDENTIFIER_EXPRESSION__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopedIdentifierExpressionAccess().getScopedIdentifierExpressionScopeAction_1_0(), semanticObject.getScope());
		feeder.accept(grammarAccess.getScopedIdentifierExpressionAccess().getIdentifierIdentifierExpressionParserRuleCall_1_2_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Selection returns Selection
	 *
	 * Constraint:
	 *     (
	 *         elements+=VariableNameOnly 
	 *         (typeDefinition=RangeTypeSpecification | typeDefinition=ScalarTypeSpecification | typeDefinition=SimpleIdentifierExpression)
	 *     )
	 */
	protected void sequence_Selection(ISerializationContext context, Selection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeExpression returns IdentifierExpression
	 *     SimpleIdentifierExpression returns IdentifierExpression
	 *
	 * Constraint:
	 *     identifier=[NamedElement|UPPAAL_TYPE_OR_IDENTIFIER]
	 */
	protected void sequence_SimpleIdentifierExpression(ISerializationContext context, IdentifierExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionsPackage.Literals.IDENTIFIER_EXPRESSION__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionsPackage.Literals.IDENTIFIER_EXPRESSION__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleIdentifierExpressionAccess().getIdentifierNamedElementUPPAAL_TYPE_OR_IDENTIFIERParserRuleCall_0_1(), semanticObject.eGet(ExpressionsPackage.Literals.IDENTIFIER_EXPRESSION__IDENTIFIER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeExpression returns StructTypeSpecification
	 *     StructTypeSpecification returns StructTypeSpecification
	 *
	 * Constraint:
	 *     declaration+=TypedElement+
	 */
	protected void sequence_StructTypeSpecification(ISerializationContext context, StructTypeSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizationLabel returns Synchronization
	 *
	 * Constraint:
	 *     (channelExpression=IdentifierExpression kind=SynchronizationKind)
	 */
	protected void sequence_SynchronizationLabel(ISerializationContext context, Synchronization semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TemplatesPackage.Literals.SYNCHRONIZATION__CHANNEL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplatesPackage.Literals.SYNCHRONIZATION__CHANNEL_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, TemplatesPackage.Literals.SYNCHRONIZATION__KIND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TemplatesPackage.Literals.SYNCHRONIZATION__KIND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSynchronizationLabelAccess().getChannelExpressionIdentifierExpressionParserRuleCall_0_0(), semanticObject.getChannelExpression());
		feeder.accept(grammarAccess.getSynchronizationLabelAccess().getKindSynchronizationKindEnumRuleCall_1_0(), semanticObject.getKind());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SystemDeclarations returns SystemDeclarations
	 *
	 * Constraint:
	 *     (declaration+=TypedDeclaration | declaration+=TypeDeclaration | declaration+=TemplateDeclaration | system=System | progressMeasure=ProgressMeasure)*
	 */
	protected void sequence_SystemDeclarations(ISerializationContext context, SystemDeclarations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     System returns System
	 *
	 * Constraint:
	 *     (instantiationList+=InstantiationList instantiationList+=InstantiationList*)
	 */
	protected void sequence_System(ISerializationContext context, org.muml.uppaal.declarations.system.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemplateDeclaration returns TemplateDeclaration
	 *
	 * Constraint:
	 *     (declaredTemplate=RedefinedTemplate (argument+=Expression argument+=Expression*)?)
	 */
	protected void sequence_TemplateDeclaration(ISerializationContext context, TemplateDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Template returns Template
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameter+=ParameterContainer parameter+=ParameterContainer*)? 
	 *         declarations=LocalDeclarations? 
	 *         location+=Location+ 
	 *         init=[Location|STRING] 
	 *         edge+=Edge*
	 *     )
	 */
	protected void sequence_Template(ISerializationContext context, Template semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns TypeDeclaration
	 *
	 * Constraint:
	 *     (typeDefinition=TypeExpression type+=DeclaredType type+=DeclaredType*)
	 */
	protected void sequence_TypeDeclaration(ISerializationContext context, TypeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedDeclaration returns TypedDeclaration
	 *
	 * Constraint:
	 *     (typeDefinition=TypeExpression (elements+=Function | (elements+=Variable elements+=Variable*)))
	 */
	protected void sequence_TypedDeclaration(ISerializationContext context, TypedDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedElement returns TypedDeclaration
	 *
	 * Constraint:
	 *     (typeDefinition=TypeExpression elements+=Variable elements+=Variable*)
	 */
	protected void sequence_TypedElement(ISerializationContext context, TypedDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableNameOnly returns Variable
	 *
	 * Constraint:
	 *     name=UPPAAL_IDENTIFIER
	 */
	protected void sequence_VariableNameOnly(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CorePackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CorePackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableNameOnlyAccess().getNameUPPAAL_IDENTIFIERParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=UPPAAL_IDENTIFIER (index+=Expression | index+=ScalarTypeSpecification)* initializer=Initializer?)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileLoop
	 *     WhileLoop returns WhileLoop
	 *
	 * Constraint:
	 *     (expression=Expression statement=Statement)
	 */
	protected void sequence_WhileLoop(ISerializationContext context, WhileLoop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.WHILE_LOOP__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.WHILE_LOOP__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, StatementsPackage.Literals.WHILE_LOOP__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementsPackage.Literals.WHILE_LOOP__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileLoopAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getWhileLoopAccess().getStatementStatementParserRuleCall_4_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
}
